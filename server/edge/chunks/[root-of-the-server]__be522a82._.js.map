{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/auth.ts"],"sourcesContent":["import { cookies } from 'next/headers'\nimport { SignJWT, jwtVerify } from 'jose'\n\nconst secretKey = process.env.SESSION_SECRET;\nconst key = new TextEncoder().encode(secretKey);\n\nexport async function encrypt(payload: any) {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime('1d')\n    .sign(key)\n}\n\nexport async function decrypt(input: string): Promise<any> {\n  try {\n    const { payload } = await jwtVerify(input, key, {\n      algorithms: ['HS256'],\n    })\n    return payload\n  } catch (error) {\n    return null\n  }\n}\n\nexport async function createSession(userId: string) {\n  const expires = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n  const session = await encrypt({ userId, expires })\n\n  cookies().set('session', session, { expires, httpOnly: true })\n}\n\nexport async function getSession() {\n  const sessionCookie = cookies().get('session')?.value\n  if (!sessionCookie) return null\n\n  const session = await decrypt(sessionCookie);\n  if (!session) return null;\n\n  if (new Date(session.expires) < new Date()) {\n    return null;\n  }\n  \n  return session;\n}\n\nexport async function deleteSession() {\n  cookies().set('session', '', { expires: new Date(0) })\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AAAA;AACA;AAAA;;;AAEA,MAAM,YAAY,QAAQ,GAAG,CAAC,cAAc;AAC5C,MAAM,MAAM,IAAI,cAAc,MAAM,CAAC;AAE9B,eAAe,QAAQ,OAAY;IACxC,OAAO,MAAM,IAAI,8JAAA,CAAA,UAAO,CAAC,SACtB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,MAClB,IAAI,CAAC;AACV;AAEO,eAAe,QAAQ,KAAa;IACzC,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,gKAAA,CAAA,YAAS,AAAD,EAAE,OAAO,KAAK;YAC9C,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEO,eAAe,cAAc,MAAc;IAChD,MAAM,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,MAAM,WAAW;;IACtE,MAAM,UAAU,MAAM,QAAQ;QAAE;QAAQ;IAAQ;IAEhD,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,WAAW,SAAS;QAAE;QAAS,UAAU;IAAK;AAC9D;AAEO,eAAe;IACpB,MAAM,gBAAgB,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,YAAY;IAChD,IAAI,CAAC,eAAe,OAAO;IAE3B,MAAM,UAAU,MAAM,QAAQ;IAC9B,IAAI,CAAC,SAAS,OAAO;IAErB,IAAI,IAAI,KAAK,QAAQ,OAAO,IAAI,IAAI,QAAQ;QAC1C,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAe;IACpB,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,WAAW,IAAI;QAAE,SAAS,IAAI,KAAK;IAAG;AACtD"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\nimport { getSession } from '@/lib/auth';\n\nexport async function middleware(request: NextRequest) {\n  const session = await getSession();\n  const { pathname } = request.nextUrl;\n\n  const isPublicPath = pathname === '/';\n\n  if (isPublicPath && session) {\n    return NextResponse.redirect(new URL('/admin', request.url));\n  }\n\n  if (!isPublicPath && !session) {\n    return NextResponse.redirect(new URL('/', request.url));\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/', '/admin/:path*'],\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAEA;;;AAEO,eAAe,WAAW,OAAoB;IACnD,MAAM,UAAU,MAAM,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD;IAC/B,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,MAAM,eAAe,aAAa;IAElC,IAAI,gBAAgB,SAAS;QAC3B,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;IAC5D;IAEA,IAAI,CAAC,gBAAgB,CAAC,SAAS;QAC7B,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;IACvD;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QAAC;QAAK;KAAgB;AACjC"}}]
}